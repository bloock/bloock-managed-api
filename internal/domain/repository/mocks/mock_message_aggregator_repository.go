// Code generated by MockGen. DO NOT EDIT.
// Source: internal/domain/repository/message_aggregator_repository.go

// Package mock_repository is a generated GoMock package.
package mock_repository

import (
	context "context"
	reflect "reflect"

	domain "github.com/bloock/bloock-managed-api/internal/domain"
	gomock "github.com/golang/mock/gomock"
)

// MockMessageAggregatorRepository is a mock of MessageAggregatorRepository interface.
type MockMessageAggregatorRepository struct {
	ctrl     *gomock.Controller
	recorder *MockMessageAggregatorRepositoryMockRecorder
}

// MockMessageAggregatorRepositoryMockRecorder is the mock recorder for MockMessageAggregatorRepository.
type MockMessageAggregatorRepositoryMockRecorder struct {
	mock *MockMessageAggregatorRepository
}

// NewMockMessageAggregatorRepository creates a new mock instance.
func NewMockMessageAggregatorRepository(ctrl *gomock.Controller) *MockMessageAggregatorRepository {
	mock := &MockMessageAggregatorRepository{ctrl: ctrl}
	mock.recorder = &MockMessageAggregatorRepositoryMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockMessageAggregatorRepository) EXPECT() *MockMessageAggregatorRepositoryMockRecorder {
	return m.recorder
}

// ExistRoot mocks base method.
func (m *MockMessageAggregatorRepository) ExistRoot(ctx context.Context, root string) (bool, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "ExistRoot", ctx, root)
	ret0, _ := ret[0].(bool)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// ExistRoot indicates an expected call of ExistRoot.
func (mr *MockMessageAggregatorRepositoryMockRecorder) ExistRoot(ctx, root interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "ExistRoot", reflect.TypeOf((*MockMessageAggregatorRepository)(nil).ExistRoot), ctx, root)
}

// FindMessagesByHashesAndRoot mocks base method.
func (m *MockMessageAggregatorRepository) FindMessagesByHashesAndRoot(ctx context.Context, hash []string, root string) ([]domain.Message, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "FindMessagesByHashesAndRoot", ctx, hash, root)
	ret0, _ := ret[0].([]domain.Message)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// FindMessagesByHashesAndRoot indicates an expected call of FindMessagesByHashesAndRoot.
func (mr *MockMessageAggregatorRepositoryMockRecorder) FindMessagesByHashesAndRoot(ctx, hash, root interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "FindMessagesByHashesAndRoot", reflect.TypeOf((*MockMessageAggregatorRepository)(nil).FindMessagesByHashesAndRoot), ctx, hash, root)
}

// GetMessageByHash mocks base method.
func (m *MockMessageAggregatorRepository) GetMessageByHash(ctx context.Context, hash string) (domain.Message, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "GetMessageByHash", ctx, hash)
	ret0, _ := ret[0].(domain.Message)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// GetMessageByHash indicates an expected call of GetMessageByHash.
func (mr *MockMessageAggregatorRepositoryMockRecorder) GetMessageByHash(ctx, hash interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetMessageByHash", reflect.TypeOf((*MockMessageAggregatorRepository)(nil).GetMessageByHash), ctx, hash)
}

// GetMessagesByRootAndAnchorID mocks base method.
func (m *MockMessageAggregatorRepository) GetMessagesByRootAndAnchorID(ctx context.Context, root string, anchorID int) ([]domain.Message, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "GetMessagesByRootAndAnchorID", ctx, root, anchorID)
	ret0, _ := ret[0].([]domain.Message)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// GetMessagesByRootAndAnchorID indicates an expected call of GetMessagesByRootAndAnchorID.
func (mr *MockMessageAggregatorRepositoryMockRecorder) GetMessagesByRootAndAnchorID(ctx, root, anchorID interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetMessagesByRootAndAnchorID", reflect.TypeOf((*MockMessageAggregatorRepository)(nil).GetMessagesByRootAndAnchorID), ctx, root, anchorID)
}

// GetPendingMessages mocks base method.
func (m *MockMessageAggregatorRepository) GetPendingMessages(ctx context.Context) ([]domain.Message, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "GetPendingMessages", ctx)
	ret0, _ := ret[0].([]domain.Message)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// GetPendingMessages indicates an expected call of GetPendingMessages.
func (mr *MockMessageAggregatorRepositoryMockRecorder) GetPendingMessages(ctx interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetPendingMessages", reflect.TypeOf((*MockMessageAggregatorRepository)(nil).GetPendingMessages), ctx)
}

// SaveMessage mocks base method.
func (m *MockMessageAggregatorRepository) SaveMessage(ctx context.Context, message domain.Message) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "SaveMessage", ctx, message)
	ret0, _ := ret[0].(error)
	return ret0
}

// SaveMessage indicates an expected call of SaveMessage.
func (mr *MockMessageAggregatorRepositoryMockRecorder) SaveMessage(ctx, message interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "SaveMessage", reflect.TypeOf((*MockMessageAggregatorRepository)(nil).SaveMessage), ctx, message)
}

// UpdateMessage mocks base method.
func (m_2 *MockMessageAggregatorRepository) UpdateMessage(ctx context.Context, m domain.Message) error {
	m_2.ctrl.T.Helper()
	ret := m_2.ctrl.Call(m_2, "UpdateMessage", ctx, m)
	ret0, _ := ret[0].(error)
	return ret0
}

// UpdateMessage indicates an expected call of UpdateMessage.
func (mr *MockMessageAggregatorRepositoryMockRecorder) UpdateMessage(ctx, m interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "UpdateMessage", reflect.TypeOf((*MockMessageAggregatorRepository)(nil).UpdateMessage), ctx, m)
}
